{"version":3,"sources":["newtonmath.js"],"names":[],"mappings":"AAAA,CAAC,UAAY,CACT,aAQA,eAA+C,CAC3C,MAAO,IAAI,QAAJ,CAAY,aAA2B,CAC1C,GACI,GADO,wBACD,GAAmB,GAAnB,CAAyB,qBADnC,CAEI,EAAM,GAAI,eAFd,CAIA,EAAI,MAAJ,CAAa,UAAY,CACF,GAAf,OAAK,MAAL,EAAoC,GAAd,MAAK,MADV,CAEjB,EAAQ,EAAI,QAAZ,CAFiB,CAIjB,EAAO,CAAC,OAAQ,KAAK,MAAd,CAAsB,IAAK,EAAI,UAA/B,CAAP,CAEP,CAXyC,CAa1C,EAAI,OAAJ,CAAc,UAAY,CACtB,EAAO,CAAC,OAAQ,KAAK,MAAd,CAAsB,IAAK,EAAI,UAA/B,CAAP,CACH,CAfyC,CAiB1C,EAAI,IAAJ,CAAS,KAAT,GAjB0C,CAkB1C,EAAI,IAAJ,EACH,CAnBM,CAoBV,CAED,iBAAuD,CACnD,OACC,IADD,CACM,KAAY,EAAS,EAAe,KAAK,KAAL,GAAf,CAAT,CADlB,EAEC,KAFD,CAEO,KAAS,EAAW,aAAX,CAA0B,EAAM,MAAhC,CAAwC,EAAM,GAA9C,CAFhB,CAGH,CAED,aAAmC,CAE/B,GAAI,EAAS,cAAT,CAAwB,OAAxB,CAAJ,CACI,EAAW,OAAX,CADJ,KAEO,CACH,GAAI,GAAS,QAAb,CAGA,GAAI,CACA,MAAO,MAAK,KAAL,GACV,CAAC,QAAU,OAEJ,GAAO,WAAP,EAAsB,MAAtB,EAAwD,KAAxB,IAAO,WAAP,EAF5B,CAGG,GAHH,EAOX,CACJ,CACJ,CAED,YAAuB,CACnB,QAAQ,KAAR,CAAc,mBAAd,CAAmC,GAAG,SAAtC,CACH,CAED,GAAI,GAAO,IAAX,CACI,EAAiB,EAAK,UAD1B,CAEI,IAFJ,CAGI,IAHJ,CAwCA,MAlCuB,WAAnB,QAAO,QAkCX,CA3BI,EAAK,UAAL,EA2BJ,EAjC0B,WAAlB,QAAO,OAAP,EAAiC,OAAO,OAiChD,GAhCQ,QAAU,OAAO,OAAP,EAgClB,EA7BI,QAAQ,UAAR,EA6BJ,EAtBA,EAAW,UAAX,CAAwB,UAAY,CAEhC,MADA,GAAK,UAAL,EACA,EACH,CAmBD,CAhBA,8HAAU,OAAV,CAAkB,KAAY,CAC1B,KAAiB,OAA0B,QADjB,CAE1B,KAAuB,IAC1B,CAHD,CAgBA,CAVA,EAAW,GAAX,CAAiB,SACb,EAAK,GAAL,CAAS,EAAK,EAAK,GAAL,EAAL,EAAT,CAAoC,KAApC,CASJ,CAPA,EAAW,OAAX,CAAqB,SACjB,EAAK,OAAL,CAAa,EAAK,EAAK,GAAL,EAAL,EAAb,CAAwC,KAAxC,CAMJ,CAJA,EAAW,IAAX,CAAkB,WACd,EAAK,IAAL,CAAU,EAAK,EAAK,GAAL,GAAgB,GAAhB,EAAL,EAAV,CAAgD,KAAhD,CAGJ,EACH,CAxGD,EAwGG,IAxGH,CAwGQ,IAxGR,C","file":"newtonmath-min.js","sourcesContent":["(function () {\r\n    'use strict';\r\n    \r\n    // Newton API endpoints\r\n    const ENDPOINTS = ['simplify', 'factor', 'derive', 'integrate', 'zeroes',\r\n                       'tangent', 'area', 'cos', 'sin', 'tan', 'arccos',\r\n                       'arcsin', 'arctan', 'abs', 'log'];\r\n    \r\n    // Core functions\r\n    function createPromise (operation, expression) {\r\n        return new Promise(function (resolve, reject) {\r\n            let base = 'https://newton.now.sh/',\r\n                url = base + operation + '/' + encodeURIComponent(expression),\r\n                xhr = new XMLHttpRequest();\r\n            \r\n            xhr.onload = function () {\r\n                if (this.status >= 200 && this.status < 300) {\r\n                    resolve(xhr.response);\r\n                } else {\r\n                    reject({status: this.status, msg: xhr.statusText});\r\n                }\r\n            };\r\n            \r\n            xhr.onerror = function () {\r\n                reject({status: this.status, msg: xhr.statusText});\r\n            };\r\n            \r\n            xhr.open(\"GET\", url);\r\n            xhr.send();\r\n        });\r\n    }\r\n    \r\n    function sendRequest (operation, expression, callback) {\r\n        createPromise(operation, expression)\r\n        .then(response => callback(handleResponse(JSON.parse(response))))\r\n        .catch(error => printError('HTTP status', error.status, error.msg));\r\n    }\r\n    \r\n    function handleResponse (response) {\r\n        // Was the expression valid?\r\n        if (response.hasOwnProperty('error')) {\r\n            printError(response['error']);\r\n        } else {\r\n            let result = response['result'];\r\n            \r\n            // Some of the strings returned can be parsed to integers or floats\r\n            try {\r\n                return JSON.parse(result);\r\n            } catch (e) {\r\n                // If the result is NaN, return NaN instead of a string\r\n                if (result.constructor == String && result.toLowerCase() == 'nan') {\r\n                    return NaN;\r\n                } else {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function printError () {\r\n        console.error('NewtonMath error:', ...arguments);\r\n    }\r\n    \r\n    let root = this,\r\n        prevNewtonMath = root.NewtonMath,\r\n        core = {},\r\n        NewtonMath = {};\r\n    \r\n    // Expose the module\r\n    if (typeof exports !== 'undefined') {\r\n        if (typeof module !== 'undefined' && module.exports) {\r\n            exports = module.exports = NewtonMath;\r\n        }\r\n        \r\n        exports.NewtonMath = NewtonMath;\r\n    } else {\r\n        root.NewtonMath = NewtonMath;\r\n    }\r\n    \r\n    // Allow module global to be renamed to remove conflicts with other vars\r\n    // of the same name (same concept as jQuery method of the same name)\r\n    NewtonMath.noConflict = function () {\r\n        root.NewtonMath = prevNewtonMath;\r\n        return NewtonMath;\r\n    };\r\n    \r\n    // Instantiate basic endpoint functionality\r\n    ENDPOINTS.forEach(endpoint => {\r\n        core[endpoint] = (expression, callback) => sendRequest(endpoint, expression, callback);\r\n        NewtonMath[endpoint] = core[endpoint];\r\n    });\r\n    \r\n    // Extend parameterised endpoint functionality\r\n    NewtonMath.log = (exp, a2, a3) =>\r\n        core.log(a3 ? a2 + '|' + exp : exp, a3 ? a3 : a2);\r\n    \r\n    NewtonMath.tangent = (exp, a2, a3) =>\r\n        core.tangent(a3 ? a2 + '|' + exp : exp, a3 ? a3 : a2);\r\n    \r\n    NewtonMath.area = (exp, a2, a3, a4) =>\r\n        core.area(a4 ? a2 + ':' + a3 + '|' + exp : exp, a4 ? a4 : a2);\r\n    \r\n    // Expose NewtonMath object\r\n    return NewtonMath;\r\n}).call(this);\r\n"]}